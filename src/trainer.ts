import net = require('./network');

/*******************************************************************************************
                                        TRAINER
*******************************************************************************************/

export class Trainer {
  network: net.Network;
  rate: any = .2;
  iterations = 100000;
  error = .005;
  cost: Trainer.ITrainerCostFn;
  schedule: any;

  constructor(network: net.Network, options?: any) {
    options = options || {};
    this.network = network;
    this.rate = options.rate || .2;
    this.iterations = options.iterations || 100000;
    this.error = options.error || .005
    this.cost = options.cost || Trainer.cost.CROSS_ENTROPY;
  }

  // trains any given set to a network
  train(set, options) {

    var error = 1;
    var iterations = 0, bucketSize = 0;
    var abort_training = false;
    var input, output, target, currentRate;

    var start = Date.now();

    if (options) {
      if (options.shuffle) {
        //+ Jonas Raoni Soares Silva
        //@ http://jsfromhell.com/array/shuffle [v1.0]
        function shuffle(o) { //v1.0
          for (var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
          return o;
        };
      }
      if (options.iterations)
        this.iterations = options.iterations;
      if (options.error)
        this.error = options.error;
      if (options.rate)
        this.rate = options.rate;
      if (options.cost)
        this.cost = options.cost;
      if (options.schedule)
        this.schedule = options.schedule;
      if (options.customLog) {
        // for backward compatibility with code that used customLog
        console.log('Deprecated: use schedule instead of customLog')
        this.schedule = options.customLog;
      }
    }

    currentRate = this.rate;
    if (Array.isArray(this.rate)) {
      bucketSize = Math.floor(this.iterations / this.rate.length);
    }


    while (!abort_training && iterations < this.iterations && error > this.error) {
      error = 0;

      if (bucketSize > 0) {
        var currentBucket = Math.floor(iterations / bucketSize);
        currentRate = this.rate[currentBucket];
      }

      for (var train in set) {
        input = set[train].input;
        target = set[train].output;

        output = this.network.activate(input);
        this.network.propagate(currentRate, target);

        error += this.cost(target, output);
      }

      // check error
      iterations++;
      error /= set.length;

      if (options) {
        if (this.schedule && this.schedule.every && iterations % this.schedule.every == 0) {

          abort_training = this.schedule.do({
            error: error,
            iterations: iterations,
            rate: currentRate
          });
     
        } else if (options.log && iterations % options.log == 0) {
          console.log('iterations', iterations, 'error', error, 'rate', currentRate, 'T:', target, 'O:', output);
        };
        if (options.shuffle)
          shuffle(set);
      }
    }

    var results = {
      error: error,
      iterations: iterations,
      time: Date.now() - start
    }

    return results;
  }

  // trains any given set to a network using a WebWorker
  workerTrain(set, callback, options) {

    var that = this;
    var error = 1;
    var iterations = 0, bucketSize = 0;
    var input, output, target, currentRate;
    var length = set.length;
    var abort_training = false;

    var start = Date.now();

    if (options) {
      if (options.shuffle) {
        //+ Jonas Raoni Soares Silva
        //@ http://jsfromhell.com/array/shuffle [v1.0]
        function shuffle(o) { //v1.0
          for (var j, x, i = o.length; i; j = Math.floor(Math.random() *
            i), x = o[--i], o[i] = o[j], o[j] = x);
          return o;
        };
      }
      if (options.iterations)
        this.iterations = options.iterations;
      if (options.error)
        this.error = options.error;
      if (options.rate)
        this.rate = options.rate;
      if (options.cost)
        this.cost = options.cost;
      if (options.schedule)
        this.schedule = options.schedule;
      if (options.customLog)
        // for backward compatibility with code that used customLog
        console.log('Deprecated: use schedule instead of customLog')
      this.schedule = options.customLog;
    }

    // dynamic learning rate
    currentRate = this.rate;
    if (Array.isArray(this.rate)) {
      bucketSize = Math.floor(this.iterations / this.rate.length);
    }

    // create a worker
    var worker = this.network.worker();

    // activate the network
    function activateWorker(input) {
      worker.postMessage({
        action: "activate",
        input: input,
        memoryBuffer: that.network.optimized.memory
      }, [that.network.optimized.memory.buffer]);
    }

    // backpropagate the network
    function propagateWorker(target) {
      if (bucketSize > 0) {
        var currentBucket = Math.floor(iterations / bucketSize);
        currentRate = this.rate[currentBucket];
      }
      worker.postMessage({
        action: "propagate",
        target: target,
        rate: currentRate,
        memoryBuffer: that.network.optimized.memory
      }, [that.network.optimized.memory.buffer]);
    }

    // train the worker
    worker.onmessage = function(e) {
      // give control of the memory back to the network
      that.network.optimized.ownership(e.data.memoryBuffer);

      if (e.data.action == "propagate") {
        if (index >= length) {
          index = 0;
          iterations++;
          error /= set.length;

          // log
          if (options) {
            if (this.schedule && this.schedule.every && iterations % this.schedule.every == 0)
              abort_training = this.schedule.do({
                error: error,
                iterations: iterations
              });
            else if (options.log && iterations % options.log == 0) {
              console.log('iterations', iterations, 'error', error);
            };
            if (options.shuffle)
              shuffle(set);
          }

          if (!abort_training && iterations < that.iterations && error > that.error) {
            activateWorker(set[index].input);
          } else {
            // callback
            callback({
              error: error,
              iterations: iterations,
              time: Date.now() - start
            })
          }
          error = 0;
        } else {
          activateWorker(set[index].input);
        }
      }

      if (e.data.action == "activate") {
        error += that.cost(set[index].output, e.data.output);
        propagateWorker(set[index].output);
        index++;
      }
    }

    // kick it
    var index = 0;
    var iterations = 0;
    activateWorker(set[index].input);
  }

  // trains an XOR to the network
  XOR(options) {

    if (this.network.inputs() != 2 || this.network.outputs() != 1)
      throw "Error: Incompatible network (2 inputs, 1 output)";

    var defaults = {
      iterations: 100000,
      log: false,
      shuffle: true,
      cost: Trainer.cost.MSE
    }

    if (options)
      for (var i in options)
        defaults[i] = options[i];

    return this.train([{
      input: [0, 0],
      output: [0]
    }, {
        input: [1, 0],
        output: [1]
      }, {
        input: [0, 1],
        output: [1]
      }, {
        input: [1, 1],
        output: [0]
      }], defaults);
  }

  // trains the network to pass a Distracted Sequence Recall test
  DSR(options) {
    options = options || {};

    var targets = options.targets || [2, 4, 7, 8];
    var distractors = options.distractors || [3, 5, 6, 9];
    var prompts = options.prompts || [0, 1];
    var length = options.length || 24;
    var criterion = options.success || 0.95;
    var iterations = options.iterations || 100000;
    var rate = options.rate || .1;
    var log = options.log || 0;
    var schedule = options.schedule || {};
    var correct = 0;
    var i = 0;
    var success = 0;
    var trial = i = correct = j = success = 0,
      error = 1,
      symbols = targets.length + distractors.length + prompts.length;

    var noRepeat = function(range, avoid) {
      var number = Math.random() * range | 0;
      var used = false;
      for (var i in avoid)
        if (number == avoid[i])
          used = true;
      return used ? noRepeat(range, avoid) : number;
    }

    var equal = function(prediction, output) {
      for (var i in prediction)
        if (Math.round(prediction[i]) != output[i])
          return false;
      return true;
    }

    var start = Date.now();

    while (trial < iterations && (success < criterion || trial % 1000 != 0)) {
      // generate sequence
      var sequence = [],
        sequenceLength = length - prompts.length;
      for (i = 0; i < sequenceLength; i++) {
        var any = Math.random() * distractors.length | 0;
        sequence.push(distractors[any]);
      }
      var indexes = [],
        positions = [];
      for (i = 0; i < prompts.length; i++) {
        indexes.push(Math.random() * targets.length | 0);
        positions.push(noRepeat(sequenceLength, positions));
      }
      positions = positions.sort();
      for (i = 0; i < prompts.length; i++) {
        sequence[positions[i]] = targets[indexes[i]];
        sequence.push(prompts[i]);
      }

      //train sequence
      var distractorsCorrect;
      var targetsCorrect = distractorsCorrect = 0;
      error = 0;
      for (i = 0; i < length; i++) {
        // generate input from sequence
        var input = [];
        for (j = 0; j < symbols; j++)
          input[j] = 0;
        input[sequence[i]] = 1;

        // generate target output
        var output = [];
        for (j = 0; j < targets.length; j++)
          output[j] = 0;

        if (i >= sequenceLength) {
          var index = i - sequenceLength;
          output[indexes[index]] = 1;
        }

        // check result
        var prediction = this.network.activate(input);

        if (equal(prediction, output))
          if (i < sequenceLength)
            distractorsCorrect++;
          else
            targetsCorrect++;
        else {
          this.network.propagate(rate, output);
        }

        var delta = 0;
        for (var j in prediction)
          delta += Math.pow(output[j] - prediction[j], 2);
        error += delta / this.network.outputs();

        if (distractorsCorrect + targetsCorrect == length)
          correct++;
      }

      // calculate error
      if (trial % 1000 == 0)
        correct = 0;
      trial++;
      var divideError = trial % 1000;
      divideError = divideError == 0 ? 1000 : divideError;
      success = correct / divideError;
      error /= length;

      // log
      if (log && trial % log == 0)
        console.log("iterations:", trial, " success:", success, " correct:",
          correct, " time:", Date.now() - start, " error:", error);
      if (schedule.do && schedule.every && trial % schedule.every == 0) {
        schedule.do({
          iterations: trial,
          success: success,
          error: error,
          time: Date.now() - start,
          correct: correct
        });

      }
    }

    return {
      iterations: trial,
      success: success,
      error: error,
      time: Date.now() - start
    }
  }

  // train the network to learn an Embeded Reber Grammar
  ERG(options) {

    options = options || {};
    var iterations = options.iterations || 150000;
    var criterion = options.error || .05;
    var rate = options.rate || .1;
    var log = options.log || 500;

    // gramar node
    var Node = function() {
      this.paths = [];
    }
    Node.prototype = {
      connect: function(node, value) {
        this.paths.push({
          node: node,
          value: value
        });
        return this;
      },
      any: function() {
        if (this.paths.length == 0)
          return false;
        var index = Math.random() * this.paths.length | 0;
        return this.paths[index];
      },
      test: function(value) {
        for (var i in this.paths)
          if (this.paths[i].value == value)
            return this.paths[i];
        return false;
      }
    }

    var reberGrammar = function() {

      // build a reber grammar
      var output = new Node();
      var n1 = (new Node()).connect(output, "E");
      var n2 = (new Node()).connect(n1, "S");
      var n3 = (new Node()).connect(n1, "V").connect(n2, "P");
      var n4 = (new Node()).connect(n2, "X")
      n4.connect(n4, "S");
      var n5 = (new Node()).connect(n3, "V")
      n5.connect(n5, "T");
      n2.connect(n5, "X")
      var n6 = (new Node()).connect(n4, "T").connect(n5, "P");
      var input = (new Node()).connect(n6, "B")

      return {
        input: input,
        output: output
      }
    }

    // build an embeded reber grammar
    var embededReberGrammar = function() {
      var reber1 = reberGrammar();
      var reber2 = reberGrammar();

      var output = new Node();
      var n1 = (new Node).connect(output, "E");
      reber1.output.connect(n1, "T");
      reber2.output.connect(n1, "P");
      var n2 = (new Node).connect(reber1.input, "P").connect(reber2.input,
        "T");
      var input = (new Node).connect(n2, "B");

      return {
        input: input,
        output: output
      }

    }

    // generate an ERG sequence
    var generate = function() {
      var node = embededReberGrammar().input;
      var next = node.any();
      var str = "";
      while (next) {
        str += next.value;
        next = next.node.any();
      }
      return str;
    }

    // test if a string matches an embeded reber grammar
    var test = function(str) {
      var node = embededReberGrammar().input;
      var i = 0;
      var ch = str.charAt(i);
      while (i < str.length) {
        var next = node.test(ch);
        if (!next)
          return false;
        node = next.node;
        ch = str.charAt(++i);
      }
      return true;
    }

    // helper to check if the output and the target vectors match
    var different = function(array1, array2) {
      var max1 = 0;
      var i1 = -1;
      var max2 = 0;
      var i2 = -1;
      for (var i in array1) {
        if (array1[i] > max1) {
          max1 = array1[i];
          i1 = i;
        }
        if (array2[i] > max2) {
          max2 = array2[i];
          i2 = i;
        }
      }

      return i1 != i2;
    }

    var iteration = 0;
    var error = 1;
    var table = {
      "B": 0,
      "P": 1,
      "T": 2,
      "X": 3,
      "S": 4,
      "E": 5
    }

    var start = Date.now();
    while (iteration < iterations && error > criterion) {
      var i = 0;
      error = 0;

      // ERG sequence to learn
      var sequence = generate();

      // input
      var read = sequence.charAt(i);
      // target
      var predict = sequence.charAt(i + 1);

      // train
      while (i < sequence.length - 1) {
        var input = [];
        var target = [];
        for (var j = 0; j < 6; j++) {
          input[j] = 0;
          target[j] = 0;
        }
        input[table[read]] = 1;
        target[table[predict]] = 1;

        var output = this.network.activate(input);

        if (different(output, target))
          this.network.propagate(rate, target);

        read = sequence.charAt(++i);
        predict = sequence.charAt(i + 1);

        var delta = 0;
        for (var k in output)
          delta += Math.pow(target[k] - output[k], 2)
        delta /= output.length;

        error += delta;
      }
      error /= sequence.length;
      iteration++;
      if (iteration % log == 0) {
        console.log("iterations:", iteration, " time:", Date.now() - start,
          " error:", error);
      }
    }

    return {
      iterations: iteration,
      error: error,
      time: Date.now() - start,
      test: test,
      generate: generate
    }
  }

}

export module Trainer {
  // Built-in cost functions
  
  export interface ITrainerCostFn {
    (target, output): number;
  }

  export var cost = {
    // Eq. 9
    CROSS_ENTROPY: function(target, output) {
      var crossentropy = 0;
      for (var i in output)
        crossentropy -= (target[i] * Math.log(output[i] + 1e-15)) + ((1 - target[i]) * Math.log((1 + 1e-15) - output[i])); // +1e-15 is a tiny push away to avoid Math.log(0)
      return crossentropy;
    },
    CROSS_ENTROPY_SOFTMAX: function(target, output) {
      var crossentropy = 0;
      for (var i in output)
        crossentropy -= target[i] * Math.log(output[i] + 1e-15);
      return crossentropy;
    },
    MSE: function(target, output) {
      var mse = 0;
      for (var i in output)
        mse += Math.pow(target[i] - output[i], 2);
      return mse / output.length;
    }
  }
}