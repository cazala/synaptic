**新增功能**：我们推荐使用[神经数据归一化器](https://github.com/adadgio/neural-data-normalizer)来让您的生活更轻松

我在发现[这个问题](https://github.com/cazala/synaptic/issues/72)之后创建了这个帖子，用户询问了如何向神经网络提供数据，而且这似乎对其他人有用，也是数据规范化的一个很好的例子。

示例训练集如下：

```
[
  {name:'workout', duration:'120', enjoy: true, time:1455063275, tags:['gym', 'weights']},
  {name:'lunch', duration:'45', enjoy: false, time:1455063275, tags:['salad', 'wine']},
  {name:'sleep', duration:'420', enjoy: true, time:1455063275, tags:['bed', 'romance']}
]
```

神经网络的工作，你需要准备一个训练集，包括输入和他们所需的输出。在这种情况下，将会是这样的：

```
("workout",  120, ['gym', 'weights']) => 'is enjoyable'
("lunch",  45, ['salad', 'wine']) => 'is not enjoyable'
("sleep",  420, ['bed', 'romance']) => 'is enjoyable'
```

但神经网络不知道什么是“锻炼”或"45"或“沙拉”，“酒”。他们只理解一个单一的输入，只包含0到1之间的值，它必须有一个固定的大小，所以所有的输入具有相同的长度。所以你需要规范你的输入/输出数据。

“名称”输入可以归类为类别。假设你有三个类别：“锻炼”，“午餐”和“睡眠”，每一个都可以用一个标志位表示（注意，这通常称为二进制化）。所以我们可以使用3位：

```
"workout" => 0, 0, 1
"lunch" => 0, 1, 0
"sleep" => 1, 0, 0
```

然后，可以将“持续时间”归一化为0到1之间的值，并设置最大值并除以它。假设您的最大持续时间是1000，那么您的输入将如下所示：

```
120 => 0.12
45 => 0.045
420 = > 0.42
```

对于“标签”类别，您可以再次使用类别，但要合并。所以我们假设你有6个类别：

```
gym => 0,0,0,0,0,1
weights => 0,0,0,0,1,0
salad => 0,0,0,1,0,0
wine => 0,0,1,0,0,0
bed => 0,1,0,0,0,0
romance => 1,0,0,0,0,0
```

那么你的输入将如下所示：

```
['gym', 'weights'] => 0,0,0,0,1,1
['salad', 'wine'] => 0,0,1,1,0,0
['bed', 'romance'] => 1,1,0,0,0,0
```

最后，“愉快”是最简单的，因为它是一个布尔值，它可以写成：

```
true => 1
false => 0
```

把所有这些放在一起你的训练集就像:

```
("workout",  120, ['gym', 'weights']) => 0,0,1 + 0.12, +  0,0,0,0,1,1 => [0,0,1,0.12,0,0,0,0,1,1]
("lunch",  45, ['salad', 'wine']) => 0,1,0 + 0.045, +  0,0,1,1,0,0 => [0,1,0,0.045,0,0,1,1,0,0] 
("sleep",  420, ['bed', 'romance']) => 1,0,0 + 0,42 + 1,1,0,0,0,0 => [1,0,0,0.42,1,1,0,0,0,0]
```

那么你的输出就是：

```
true => 1 => [1]
false => 0 => [0]
true => 1 => [1]
```

现在，您需要将其转换为 synaptic。你需要一个网络，在输入层有10个神经元，在输出层有1个神经元（因为这是你输入和输出的大小）。你可以选择不同的架构。如果训练集的顺序很重要，则需要使用带有上下文内存的网络，如LSTM。如果顺序不重要，那么你应该使用 Perceptron，这是不知情的情况。

我的意思是，如果这样的话：

```
("workout",  120, ['gym', 'weights']) => true 
("lunch",  45, ['salad', 'wine']) => false 
("sleep",  420, ['bed', 'romance']) => true 
```

应或不应与此相同：

```
("lunch",  45, ['salad', 'wine']) => false 
("workout",  120, ['gym', 'weights']) => true 
("sleep",  420, ['bed', 'romance']) => true 
```

如果，比方说，之前的工作会改变睡眠设置输出吃午饭的时候，你需要使用一个网络，记得以前的激活（LSTM）。

但是为了保持简单，我们假设集合的顺序不重要，并使用感知器。

```js
var myNet = new Architect.Perceptron(10, 7, 1);
```

我用10个输入、7个隐藏神经元和1个输出神经元来创建它。隐层神经元的数目不能猜测你直截了当地通常使用数字输入和输出之间的数量。

现在，你将你的训练集送到网络的训练师那里：

```js
var trainingSet = [
  {
    input: [0,0,1,0.12,0,0,0,0,1,1],
    output: [1]
  },
  {
    input:  [0,1,0,0.045,0,0,1,1,0,0],
    output: [0]
  },
  {
    input:  [1,0,0,0.42,1,1,0,0,0,0],
    output: [1]
  }
]

var trainingOptions = {
  rate: .1,
  iterations: 20000,
  error: .005,
}

myNet.trainer.train(trainingSet, trainingOptions);
```

如果在结果中收到 `NaN`，请确认您的输入/输出值，并且输入节点的数量不大于输入数组的长度。

训练选项应根据每个特殊情况进行调整，您可以在[训练器](https://github.com/cazala/synaptic/wiki/Trainer)页面阅读更多关于训练器选项的信息